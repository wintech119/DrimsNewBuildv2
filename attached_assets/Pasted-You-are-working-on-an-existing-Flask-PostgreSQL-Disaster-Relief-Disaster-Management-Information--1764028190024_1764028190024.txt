You are working on an existing Flask + PostgreSQL Disaster Relief / Disaster Management Information System (DRIMS / DIMS).

The current database schema is defined in this file (read-only reference):

/mnt/data/drms-2.2.sql

We now need to update/align the donation table so that its structure matches the DDL shown below, without:

Breaking referential integrity

Breaking any existing logic, UI, workflows, or behaviour

Breaking any security fixes (e.g., CSP, CSRF, RBAC, etc.)

Losing any existing data

Target DDL (final shape of donation)

Use this definition as the source of truth for how the donation table must look after the migration:

create table donation
(
	donation_id integer not null generated by default as identity
		constraint pk_donation primary key,

	--Donor and description of donation received
	donor_id integer not null
		constraint fk_donation_donor references donor,
	donation_desc text not null,

	origin_country_id smallint not null
		constraint fk_donation_country references country,
	origin_address1_text varchar(255),
	origin_address2_text varchar(255),

	--Event for which donation was made. Default to ADHOC.
	event_id integer not null
		constraint fk_donation_event references event,
	
	--Agency that collected donation and date of collection
	custodian_id integer not null
		constraint fk_donation_custodian references custodian,

	received_date date not null
		constraint c_donation_1 check (received_date <= CURRENT_DATE),

	--Sum of item cost over all items cost(s) and funds donated
	tot_item_cost decimal(12,2) not null
		constraint c_donation_2 check (tot_item_cost > 0.00),

	storage_cost decimal(12,2) not null
		constraint c_donation_2a check (storage_cost > 0.00),

	haulage_cost decimal(12,2) not null
		constraint c_donation_2b check (haulage_cost > 0.00),

	--Other costs
	other_cost decimal(12,2) not null
		constraint c_donation_2c check (other_cost > 0.00),
	--Description of other costs incurred
	other_cost_desc varchar(255),

	status_code char(1) not null
		--E=Entered, V=Verified, P=Processed
		constraint c_donation_3 check (status_code in ('E','V','P')),

	--Any comments related to the receipt of donation
	comments_text text,

	create_by_id varchar(20) not null,
	create_dtime timestamp(0) without time zone not null,
	update_by_id varchar(20) not null,
	update_dtime timestamp(0) without time zone not null,
	verify_by_id varchar(20) not null,
	verify_dtime timestamp(0) without time zone not null,
	version_nbr integer not null
);

HARD CONSTRAINTS (DO NOT VIOLATE)

Do NOT break referential integrity

Identify all tables that reference donation via foreign keys (e.g. donation_item, dnintake, dnintake_item, donation_doc, etc.) based on /mnt/data/drms-2.2.sql.

Ensure that their foreign keys keep working after the migration.

Do not drop or change any foreign key that’s not strictly necessary.

Do NOT break any app logic, UI, workflows, or behaviour

All existing donation-related flows (create, edit, accept, intake, packaging, dashboards, reporting) must continue to work as before, or better.

If the app expects certain columns, types, or constraints, keep them compatible or stricter—but not looser in a way that would bypass existing checks.

Do NOT touch security fixes

Do not modify:

CSP headers

CSRF protection

Auth / RBAC

Cookies or session handling

The migration must be database-only and safe.

Minimal change principle

First, introspect the existing donation table definition (from the live DB and/or /mnt/data/drms-2.2.sql).

Compute the diff versus the target DDL above.

Only apply the minimal set of ALTER TABLE operations needed (add/drop/alter columns, constraints, defaults, or checks).

Do not rename table or primary key; keep donation_id and pk_donation intact.

WHAT YOU MUST DO

Inspect current schema

Read /mnt/data/drms-2.2.sql to see the current donation table definition and all foreign keys that reference it.

In the running PostgreSQL instance, run \d donation (or equivalent) to confirm the live table structure.

Compute differences

Compare the live donation table with the target DDL.

Identify, for example (depending on actual diff):

Columns missing in the live table that exist in target.

Columns existing in live that are not in target (these should generally be kept unless we are 100% sure they are obsolete).

Differences in data types (e.g. origin_country_id type, text vs varchar).

Missing or mismatched check constraints (c_donation_1, c_donation_2 etc.).

Missing or mismatched foreign keys (fk_donation_donor, fk_donation_country, fk_donation_event, fk_donation_custodian).

Plan a safe migration

Use either:

Direct ALTER TABLE statements, or

A “shadow table” approach:

Create donation_new with the target DDL.

Copy data from donation into donation_new, carefully mapping columns.

Temporarily drop or defer foreign keys referencing donation.

Rename old donation → donation_old, donation_new → donation.

Recreate foreign keys to point to the new donation.

This must be done without data loss and keeping PK values intact.

Prefer ALTER TABLE in-place if differences are small and compatible.

Handle NOT NULL and CHECK constraints safely

If adding a new NOT NULL column (or tightening constraints), ensure:

Existing rows get a sensible default that respects business rules.

Example: for any numeric cost fields that need to be NOT NULL with > 0.00, default existing rows to 0.01 or a business-agreed minimum, only if that matches the existing logic; otherwise, keep them nullable and add a TODO comment in code/test instead of silently breaking constraints.

For check constraints (c_donation_1, c_donation_2, etc.):

Ensure all existing data already satisfies them; if not, fix data first (via targeted UPDATE) before adding the constraints.

Keep all existing column names

Do not rename any columns used by the application code (e.g. status_code, create_by_id, create_dtime, etc.).

Preserve donation_id as the primary key identity column so downstream tables (donation_item, dnintake, etc.) continue to work.

Maintain referential integrity

Before any disruptive change:

Identify all foreign keys referencing donation.donation_id.

If you must use the shadow-table approach:

Temporarily drop those foreign keys.

After renaming, recreate them exactly as they were.

Ensure no orphan rows are created in related tables.

Do not change application code, UI, or security config

The migration script should be:

A SQL migration file, or

An Alembic-style migration consistent with the project’s existing pattern.

It must be runnable as part of the existing migration process without requiring changes to Flask routes, templates, or security middleware.

DELIVERABLE

Produce a PostgreSQL migration script (SQL or Alembic migration) that:

Safely updates the donation table in the running DB to match the target DDL above.

Preserves all data in donation and all related tables.

Preserves referential integrity and all foreign keys.

Passes all existing constraints and does not break any app logic or security configuration.