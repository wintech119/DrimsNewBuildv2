Your task is to safely drop and recreate the dnintake_item table so that it matches the target DDL below, while:

Preserving referential integrity with all related tables

Not breaking any existing workflows, business logic, or UI

Not weakening or altering any security fixes (CSP, CSRF, auth/RBAC, cookies, sessions)

Not permanently changing any other table schemas (only temporary FK drops/re-adds if strictly needed)

Assume there may be data in dnintake_item and handle it safely via a shadow-table pattern.

ðŸŽ¯ TARGET DDL â€” FINAL STRUCTURE OF dnintake_item

After the migration, dnintake_item must match this DDL exactly:

create table dnintake_item
(
    donation_id integer not null,
    inventory_id integer not null,
    item_id integer not null,

    --Batch number assigned by manufacturer or by ODPEM (where there is no batch number).
    --If no batch number is assigned, set value of field to item code.
    --If batch does not exist, create it with a batch id and zero quantities (i.e. empty).
    --Update batch amounts with the amounts being taken in.
    batch_no varchar(20) --not null
        constraint c_dnintake_item_1a check (batch_no = upper(batch_no)),

    batch_date date not null
        constraint c_dnintake_item_1b check (batch_date <= CURRENT_DATE),

    expiry_date date not null
        constraint c_dnintake_item_1c check (expiry_date >= CURRENT_DATE),

    --Units in which quantity of item is measured
    uom_code varchar(25) not null
        constraint fk_dnintake_item_unitofmeasure references unitofmeasure,

    avg_unit_value decimal(10,2) not null
        constraint c_dnintake_item_1d check (avg_unit_value > 0.00),

    --Extended item cost =
    --  (usable_qty + defective_qty + expired_qty) * avg_unit_value
    ext_item_cost decimal(12,2) not null
        default ((usable_qty + defective_qty + expired_qty) * avg_unit_value)
        constraint c_dnintake_item_1c
        check (ext_item_cost = (usable_qty + defective_qty + expired_qty) * avg_unit_value),

    --Quantity/amount of usable/good item in inventory
    usable_qty decimal(12,2) not null
        constraint c_dnintake_item_2 check (usable_qty >= 0.00),

    --Quantity/amount of defective item in inventory
    defective_qty decimal(12,2) not null
        constraint c_dnintake_item_3 check (defective_qty >= 0.00),

    --Quantity/amount of expired item in inventory
    expired_qty decimal(12,2) not null
        constraint c_dnintake_item_4 check (defective_qty >= 0.00),

    status_code char(1) not null
        --P=Pending verification, V=Verified
        constraint c_dnintake_item_5 check (status_code in ('P','V')),

    comments_text varchar(255),

    create_by_id varchar(20) not null,
    create_dtime timestamp(0) without time zone not null,
    update_by_id varchar(20) not null,
    update_dtime timestamp(0) without time zone not null,
    version_nbr integer not null,

    constraint fk_dnintake_item_intake 
        foreign key (donation_id,inventory_id) 
        references dnintake(donation_id,inventory_id),

    constraint fk_dnintake_item_donation_item 
        foreign key(donation_id,item_id)
        references donation_item(donation_id,item_id),

    constraint pk_dnintake_item 
        primary key(donation_id,inventory_id,item_id,batch_no)
);

create index dk_dnintake_item_1 on dnintake_item(inventory_id, item_id);
create index dk_dnintake_item_2 on dnintake_item(item_id);

ðŸš¨ HARD CONSTRAINTS (DO NOT VIOLATE)

Retain referential integrity

dnintake_item depends on:

dnintake(donation_id, inventory_id) via fk_dnintake_item_intake

donation_item(donation_id, item_id) via fk_dnintake_item_donation_item

unitofmeasure(uom_code) via fk_dnintake_item_unitofmeasure

After migration, all these relationships must remain valid and enforced.

If any other tables reference dnintake_item (unlikely but check), treat them similarly: drop FKs temporarily and recreate them.

Do NOT change any other tableâ€™s structure

No permanent DDL changes to:

dnintake

donation_item

unitofmeasure

Any other table

Only temporary FK drops/re-adds are allowed.

Do NOT break app logic, workflows, UI, or security

All DRIMS flows that use dnintake_item must continue to work:

Intake capturing

Batch management and FEFO/FIFO logic

Inventory quantity tracking

Verification workflows and dashboards

Do not touch CSP, CSRF, auth, RBAC, cookies, sessions, or any Flask routes/templates.

Use a shadow-table (swap) strategy

Because there may be data in dnintake_item, you must:

Create dnintake_item_new with the target DDL

Copy data from the existing table into the new one (with column mapping)

Drop FKs that reference the old table (if any)

Rename tables (old â†’ _old, new â†’ live)

Recreate indexes and FKs